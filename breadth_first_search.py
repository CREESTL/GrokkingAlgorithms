'''

Поиск в ширину отвечает на два вопроса:
1) Существует ли путь от А к Б
2) Какой путь от А к Б - кратчайший?

Данные для поиска в ширину представляются в виде графа. Для графа используется словарь (хэш-таблица)
Ключ словаря - вершина графа, значения - соседние вершины графа.

Для реализации используется очередь(FIFO) (а стек, кстати, - LIFO)
Представим, что весь граф идет из одной центральной точки. Сначала необходимо проверить
первый уровень соседних узлов(возможно, искомый - там), а лишь потом - второй и т.д.
Берем из очереди первый узел. Проверяем, является ли он искомым, если да - прекращаем, если нет - добавляем
всех его соседей в конец очереди. Как раз из-за того, что сначала проверяются все соседи в одно радиусе,
алгоритм найдет кратчайшее расстояние.

Каждый узел необходимо отмечать, как проверенный, чтобы не было циклов и дубликатов.

Обычно ребра двунаправленные. Если они направлены только в одну сторону - это дерево.

Время выполнения = О(узлы, ребра)
'''

from collections import deque

# подготовим граф
graph = {}
graph['you'] = ['alice', 'bob', 'claire']
graph['bob'] = ['anuj', 'peggy']
graph['alice'] = ['peggy']
graph['claire'] = ['thom', 'johnny']
graph['anuj'] = []
graph['peggy'] = []
graph['thom'] = []
graph['johnny'] = []


# если последняя буква имени - m, то это искомый человек
def check_if_right(name):
    return name[-1] == 'm'


# функция поиска в ширину
# name - начальный узел для поиска
def breadth_first_search(name):
    checked = []
    # так создается двунаправленная очередь
    queue = deque()
    queue += graph[name]
    while queue:
        # извлекаем слева из очереди человека
        person = queue.popleft()
        if person not in checked:
            if check_if_right(person):
                print(f"Found {person}")
                return
            else:
                # добавление всех соседних узло в конец очереди
                queue += graph[person]
                checked.append(person)


breadth_first_search('you')


