'''

Базовый случай сортировки массива - массив с одним элементом (его просто возвращаем)
Суть:
1) Выбрать опорный элемент (например первый). Скорость работы СИЛЬНО зависит от выбора этого элемента!
2) Разбить все оставшиеся элементы на два подмассива:
-- те, которые меньше опорного (ставим слева от него)
-- те, которые больше опорного (ставим справа от него)
3) Рекурсивно применяем это для обоих подмассивов

Доказательство по индукци:
Допустим я хочу подняться до конца лестницы. Индукционный переход - если мои ного стоят на ступеньке,
то я могу поставить их на следующую. Если на 2 - то на 3, если на 3 - то на 4. И так далее.
Так доказывается, что алгоритм быстрой сортировки применим для массива любого размера.

Время выполнения - O(nlogn) - в средем; O(n^2) - в худшем случае
Худший случай - когда входной массив уже отсортирован, тогда подмассив будет только справа всегда (если в
качестве опорного элемента брать первый).
Лучший случай - когда в качестве опорного элемента брать средний.

Важно понимать, что быстрая сортировка массива из 10 элементов и сортировка массива из 100 элементов - обе происходят
за всеря O(logn)
'''
import random
import time

def quick_sort(arr):
    if len(arr) < 2:
        return arr
    else:
        base = arr[0]
        left = [el for el in arr[1:] if el < base]
        right = [el for el in arr[1:] if el > base]
        return quick_sort(left) + [base] + quick_sort(right)


arr = [random.randint(0,100) for i in range(2000)]
start_time = time.time()
arr = quick_sort(arr)
end_time = time.time()
print(f"Quick sorting finished in {end_time - start_time:1.10f} seconds")
print(arr)
