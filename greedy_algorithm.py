'''

Жадный алгоритм применяется, когда нахождение точного решения занимает неоправданно много времени.
Жадный алгоритм дает приближенное решение за короткое время.
Жадный алгоритм проще в реализации.

Пример 1: есть грузовик и коробки разных размеров, надо заполнить грузовик
    Оптимальное решение: перепробовать все комбинации коробок и найти ту, которая вмещает больше всего коробок
    Приближенное решение: положить самую большую коробку, положить вторую по величине коробку, третью...

Пример 2: есть список радиостанций, каждый из которых покрывает некоторые штаты, надо покрыть все штаты меньшим
    числом станций, так как каждая стоит денег.
    Оптимальное решение: сделать множество подмножеств всех станций из 2^n элементов и среди них найти то, которое
    покрывает все штаты и имеет меньше всего элементов.
    Приближенное решение: выбрать станцию, которая покрывает наибольшее количество штатов, еще не покрытых (если она
    будет затрагивать часть покрытых - ничего страшного), затем снова выбрать такую станцию, повторять, пока остаются
    штаты, не входящие в покрытие.
    Этот пример реалиуем.

NP-полная задача - эта та, в которой перебираются все варианты (что обычно очень затратно) и из них выбирается лучший
Задача о коммивояжере и вот эта (о покрытии множества) - классические примеры NP-полных задач.
Когда они встречаются - лучше сразу искать жадное решение.

Признаки NP-полных задач:
1) Алгоритм работает быстро, если элементов мало и медленно, если элементов много
2) В задаче есть формулировка "все комбинации..."
3) Задачу можно переформулировать так, чтобы она стала задачей о коммивояжере или о покрытии множества
'''

# ПОДГОТОВКА ДАННЫХ
# set - множество (как массив, только не содержит дубликатов)
# два варианты записи: set([...]) и {....}
# с множествами можно выполнять объединение, вычитание и т.д.
states = {'mt', 'wa', 'or', 'id', 'nv', 'ut', 'ca', 'az'}
# станции с покраваемыми штатами
stations = {}
stations['kone'] = {'id', 'nv', 'ut'}
stations['ktwo'] = {'wa', 'id', 'mt'}
stations['kthree'] = {'or', 'nv', 'ca'}
stations['kfour'] = {'nv', 'ut'}
stations['kfive'] = {'ca', 'az'}
# итоговый набор станций
final_stations = set()

def greedy_search(states, stations, final_stations):
    while states:
        print('\n\n NEW ITERATION')
        # станция с наибольшим покрытием
        best_station = None
        # максимальное количество штатов, покрытое в итерации
        max_covered_in_iteration = set()
        for station, states_of_station in stations.items():
            # пересечение множеств - те штаты, которые нужно покрыть, и которые станция МОЖЕТ покрыть
            useful_covered = states & states_of_station
            print(f'station {station} covers {useful_covered} states and length of max_covered_in_iteration is {len(max_covered_in_iteration)}')
            # важно, чтобы количество покрытых штатов росло
            if len(useful_covered) > len(max_covered_in_iteration):
                print(f'now {station} in the best station')
                best_station = station
                print(f'now states_covered is {useful_covered}')
                max_covered_in_iteration = useful_covered
        # после того, как прошлись по всем станциям - из общей массы штатов мы убираем те, которые уже покрыты
        states -= max_covered_in_iteration
        print(f'now states is {states}')
        # добавляем станцию в итоговое множество
        # здесь функция add(), а не append()
        final_stations.add(best_station)


greedy_search(states, stations, final_stations)
print(f'\nHere are best stations: {final_stations}')

